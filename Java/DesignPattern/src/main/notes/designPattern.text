设计原则
    一、找出应用中可能需要变化之处，把它们独立出来，不要和哪些不需要变化的代码混在一起
    二、针对接口编程，而不是针对实现编程
    三、多用组合，少用继承
    四、为了交互对象之间的松耦合设计而努力
    五、类应该对扩展开放，对修改关闭

一、Strategy（策略模式）
    1.概念
        定义了算法族，分别封装起来，让它们之间可以互相替换，此模式让算法的变化独立于使用算法的客户。
    2.理解
        将易于变化的部分（行为或者属性）取出并封装起来，让其他不会轻易变化的部分受到影响，以便以后可以轻易的改动或者扩充此部分。
    3.示例解析
        Duck类内的fly和quack回随着鸭子的不同而不断改变,所以应该将它们从Duck中取出来封装成对应的鸭子行为FlyBehavior(飞行为)和
    QuackBehavior(叫行为),而FlyNoWay、FlyWithWings、FlyRocketPow、Quack、Squeak、MuteQuack则是实现FlyBehavior和QuackBehavior
    的不同行为。ModelDuck和MallardDuck则继承了Duck实现了客户对鸭子的不同需求。如有需要，还可以在运行中使用setFlyBehavior、
    setQuackBehavior改变其行为。

二、Observer（观察者模式）
    1.概念
        定义了对象之间的一对多依赖，这样一来，当一个对象改变状态时，它的所有依赖者都会收到通知并自动更新。
    2.要点
        2.1 观察者模式定义了对象之间得一对多得关系。
        2.2 主题(也就是可观察者)用一个共同得接口来更新观察者。
        2.3 观察者和可观察者之间用松耦合方式结合(loosecoupling)，可观察者不知道观察者得细节，值知道观察者实现了观察者接口。
        2.4 使用此模式是，你可从被观察者出推(push)或拉(pull)数据(然而，腿的方式被认为更“正确”)。
        2.5 有多个观察者时，不可以依赖特定的通知次序。
        2.6 Java有多种观察者模式得实现，包括了通用得java.util.Observable。
        2.7 要注意java.util.Observable得实现上所带来得一些问题。
        2.8 如果有必要的话，可以实现自己的Observable。
        2.9 Swing大量使用观察者模式，许多GUI框架也是如此。
        2.10 此模式也被应用在许多地方，例如：JavaBeans，RMI。

三、decorator（装饰者模式）
    1.概念
        动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。
    2.要点
        2.1 继承属于扩展形式之一，但不见得是达到弹性设计的最佳方式。
        2.2 在我们的设计中，应该允许行为可以被扩展，而无须修改现有的代码。
        2.3 组合和委托可用于再运行时动态地加上新的行为。
        2.4 除了继承，装饰者模式也可以让我们扩展行为。
        2.5 装饰者模式意味着一群装饰者类，这些类用来包装具体组件。
        2.6 装饰者类反映出被装饰的组件类型（事实上，他们具有相同的类型，都经过接口或继承实现）。
        2.7 装饰者可以在被装饰者的行为前面与/或后面加上自己的行为，甚至将被装饰者的行为整个取代掉，而达到特定的目的。
        2.8 你可以用无数个装饰者包装一个组件
        2.9 装饰者一般对组件的客户是透明的。除非客户程序依赖于组件的具体类型。
        2.10 装饰者会导致设计中出现许多小对象，如果过度使用，会让程序变得很复杂。

四、factory（工厂模式）
    1.概念

    2.要点

